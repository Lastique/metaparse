<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<h1 id="boostmetaparse-user-manual">boost::metaparse user manual</h1>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#what-is-a-parser">What is a parser</a>
<ul>
<li><a href="#the-input-of-the-parsers">The input of the parsers</a></li>
<li><a href="#source-positions">Source positions</a></li>
<li><a href="#error-handling">Error handling</a></li>
<li><a href="#some-examples-of-simple-parsers">Some examples of simple parsers</a></li>
</ul></li>
<li><a href="#combining-parsers">Combining parsers</a>
<ul>
<li><a href="#sequence">Sequence</a></li>
<li><a href="#repetition">Repetition</a>
<ul>
<li><a href="#introducing-foldl">Introducing foldl</a></li>
<li><a href="#introducing-foldr">Introducing foldr</a></li>
<li><a href="#introducing-foldlp">Introducing foldlp</a></li>
<li><a href="#introducing-foldrp">Introducing foldrp</a></li>
<li><a href="#introducing-foldlfp">Introducing foldlfp</a></li>
<li><a href="#finding-the-right-folding-parser-combinator">Finding the right folding parser combinator</a></li>
</ul></li>
<li><a href="#grammars">Grammars</a></li>
</ul></li>
<li><a href="#parsing-based-on-constexpr">Parsing based on <code>constexpr</code></a></li>
<li><a href="#monadic-parsing">Monadic parsing</a></li>
</ul>
<h2 id="what-is-a-parser">What is a parser</h2>
<p>See the <a href="parser.html">parser</a> section of the <a href="refernce.html">reference</a> for the explanation of what a parser is.</p>
<h3 id="the-input-of-the-parsers">The input of the parsers</h3>
<p>Parsers take a <a href="string.html"><code>string</code></a> as input, which represents a string for template metaprograms. For example the string <code>&quot;Hello World!&quot;</code> can be defined the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">string&lt;&#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;,&#39; &#39;,&#39;W&#39;,&#39;o&#39;,&#39;r&#39;,&#39;l&#39;,&#39;d&#39;,&#39;!&#39;&gt;</code></pre>
<p>This syntax makes the input of the parsers difficult to read. Metaparse works with compilers using C++98, but the input of the parsers has to be defined the way it is described above.</p>
<p>Based on <code>constexpr</code>, a feature provided by C++11, Metaparse provides a macro, <a href="BOOST_STRING.html"><code>BOOST_STRING</code></a> for defining strings:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">BOOST_STRING(<span class="st">&quot;Hello World!&quot;</span>)</code></pre>
<p>This defines a <a href="string.html"><code>string</code></a> as well, however, it is easier to read. The maximum length of the string that can be defined this way is limited, however, this limit is configurable. It is specified by the <code>BOOST_LIMIT_STRING_SIZE</code> macro.</p>
<h3 id="source-positions">Source positions</h3>
<p>A source position is described using a compile-time data structure. The following functions can be used to query it:</p>
<ul>
<li><a href="get_col.html"><code>get_col</code></a></li>
<li><a href="get_line.html"><code>get_line</code></a></li>
</ul>
<p>The beginning of the input is <a href="start.html"><code>start</code></a> which requires <code>&lt;boost/metaparse/start.hpp&gt;</code> to be included.</p>
<h3 id="error-handling">Error handling</h3>
<p>An error is described using a compile-time data structure. It contains information about the source position where the error was detected and some <a href="parsing_error_message.html">description</a> about the error. <a href="debug_parsing_error.html"><code>debug_parsing_error</code></a> can be used to display the error message. Metaparse provides the <a href="BOOST_DEFINE_ERROR.html"><code>BOOST_DEFINE_ERROR</code></a> macro for defining simple <a href="parsing_error_message.html">parsing error message</a>s.</p>
<h3 id="some-examples-of-simple-parsers">Some examples of simple parsers</h3>
<ul>
<li>A parser that parses nothing and always succeeds is <a href="return_.html"><code>return_</code></a>.</li>
<li>A parser that always fails is <a href="fail.html"><code>fail</code></a>.</li>
<li>A parser that parses one character and returns the parsed character as the result is <a href="one_char.html"><code>one_char</code></a>.</li>
</ul>
<h2 id="combining-parsers">Combining parsers</h2>
<p>Complex parsers can be built by combining simple parsers. The parser library contains a number of parser combinators that build new parsers from already existing ones.</p>
<p>For example <a href="accept_when.html"><code>accept_when</code></a><code>&lt;Parser, Predicate, RejectErrorMsg&gt;</code> is a parser. It uses <code>Parser</code> to parse the input. When <code>Parser</code> rejects the input, the combinator returns the error <code>Parser</code> failed with. When <code>Parser</code> is successful, the combinator validates the result using <code>Predicate</code>. If the predicate returns true, the combinator accepts the input, otherwise it generates an error with the message <code>RejectErrorMsg</code>.</p>
<p>Having <a href="accept_when.html"><code>accept_when</code></a>, <a href="one_char.html"><code>one_char</code></a> can be used to build parsers that accept only digit characters, only whitespaces, etc. For example <a href="digit.html"><code>digit</code></a> accepts only digit characters:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">typedef</span>
  boost::metaparse::accept_when&lt;
    boost::metaparse::one_char,
    boost::metaparse::util::is_digit,
    boost::metaparse::errors::digit_expected
  &gt;
  digit;</code></pre>
<h3 id="sequence">Sequence</h3>
<p>The result of a successful parsing is some value and the remaining string that was not parsed. The remaining string can be processed by another parser. The parser library provides a parser combinator, <a href="sequence.html"><code>sequence</code></a>, that takes a number of parsers as arguments and builds a new parser from them that:</p>
<ul>
<li>Parses the input using the first parser</li>
<li>If parsing succeeds, it parses the remaining string with the second parser</li>
<li>It continues applying the parsers in order as long as they succeed</li>
<li>If all of them succeed, it returns the list of results</li>
<li>If any of the parsers fails, the combinator fails as well and returns the error the first failing parser returned with</li>
</ul>
<h3 id="repetition">Repetition</h3>
<p>It is a common thing to parse a list of things of unknown length. As an example let's start with something simple: the text is a list of numbers. For example:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dv">11</span> <span class="dv">13</span> <span class="dv">3</span> <span class="dv">21</span></code></pre>
<p>We want the result of parsing to be the sum of these values. Metaparse provides the <a href="int.html"><code>int_</code></a> parser we can use to parse one of these numbers. Metaparse provides the <a href="token.html"><code>token</code></a> combinator to consume the whitespaces after the number. So the following parser parses one number and the whitespaces after it:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> int_token = token&lt;int_&gt;;</code></pre>
<p>The result of parsing is a boxed integer value: the value of the parsed number. For example parsing <a href="BOOST_STRING.html"><code>BOOST_STRING</code></a><code>(&quot;13  &quot;)</code> gives <code>boost::mpl::int_&lt;13&gt;</code> as the result.</p>
<p>Our example input is a list of numbers. Each number can be parsed by <code>int_token</code>:</p>
<p align="center">
  
<a href="any_diag0.png"><img src="any_diag0.png" style="width:70%" /></a>
</p>

<p>This diagram shows how the repeated application of <code>int_token</code> can parse the example input. Metaparse provides the <a href="any.html"><code>any</code></a> parser to easily implement this. The result of parsing is a typelist: the list of the individual numbers.</p>
<p align="center">
  
<a href="any_diag1.png"><img src="any_diag1.png" style="width:70%" /></a>
</p>

<p>This diagram shows how <a href="any.html"><code>any</code></a><code>&lt;int_token&gt;</code> works. It uses the <code>int_token</code> parser repeatedly and builds a <code>boost::mpl::vector</code> from the results it provides.</p>
<p>But we need the sum of these, so we need to summarise the result. We can do this by wrapping our parser, <a href="any.html"><code>any</code></a><code>&lt;int_token&gt;</code> with <a href="transform.html"><code>transform</code></a>. That gives us the opportunity to specify a function transforming this typelist to some other value - the sum of the elements in our case. Initially let's ignore how to summarise the elements in the vector. Let's assume that it can be implemented by a lambda expression and use <code>boost::mpl::lambda&lt;...&gt;::type</code> representing that lambda expression. Here is an example using <a href="transform.html"><code>transform</code></a> and this lambda expression:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> sum_parser =
  transform&lt;
    any&lt;int_token&gt;,
    boost::mpl::lambda&lt;...&gt;::type
  &gt;;</code></pre>
<p>The <a href="transform.html"><code>transform</code></a><code>&lt;&gt;</code> parser combinator wraps the <a href="any.html"><code>any</code></a><code>&lt;int_token&gt;</code> to build the parser we need. Here is a diagram showing how it works:</p>
<p align="center">
  
<a href="any_diag2.png"><img src="any_diag2.png" style="width:70%" /></a>
</p>

<p>As the diagram shows, the <a href="transform.html"><code>transform</code></a><code>&lt;</code><a href="any.html"><code>any</code></a><code>&lt;int_token&gt;, ...&gt;</code> parser parses the input using <a href="any.html"><code>any</code></a><code>&lt;int_token&gt;</code> and then does some processing on the result of parsing.</p>
<p>Let's implement the missing lambda expression that tells <a href="transform.html"><code>transform</code></a> how to change the result coming from <a href="any.html"><code>any</code></a><code>&lt;int_token&gt;</code>. We can summarise the numbers in a typelist by using Boost.MPL's <code>fold</code> or <code>accumulate</code>. Here is an example doing that:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> sum_op = mpl::lambda&lt;mpl::plus&lt;mpl::_1, mpl::_2&gt;&gt;::type;

<span class="kw">using</span> sum_parser =
  transform&lt;
    any&lt;int_token&gt;,
    mpl::lambda&lt;
      mpl::fold&lt;mpl::_1, mpl::int_&lt;<span class="dv">0</span>&gt;, sum_op&gt;
    &gt;::type
  &gt;;</code></pre>
<p>Here is an extended version of the above diagram showing what happens here:</p>
<p align="center">
  
<a href="any_diag3.png"><img src="any_diag3.png" style="width:70%" /></a>
</p>

<p>This example parses the input, builds the list of numbers and then loops over it and summarises the values. It starts with the second argument of <code>fold</code>, <code>int_&lt;0&gt;</code> and adds every item of the list of numbers (which is the result of the parser <a href="any.html"><code>any</code></a><code>&lt;int_token&gt;</code>) one by one.</p>
<blockquote>
<p>Note that <a href="transform.html"><code>transform</code></a> wraps another parser, <a href="any.html"><code>any</code></a><code>&lt;int_token&gt;</code> here. It parses the input with that parser, gets the result of that parsing and changes that result. <a href="transform.html"><code>transfrom</code></a> itself will be a parser returning that updated result.</p>
</blockquote>
<h4 id="introducing-foldl">Introducing foldl</h4>
<p>It works, however, this is rather inefficient: it has a loop parsing the integers one by one, building a typlist and then it loops over this typelist to summarise the result. Using template metaprograms in your applications can have a serious impact on the compiler's memory usage and the speed of the compilation, therefore I recommend being careful with these things.</p>
<p>Metaparse offers more efficient ways of achieving the same result. You don't need two loops: you can merge them together and add every number to your summary right after parsing it. Metaparse offers the <a href="foldl.html"><code>foldl</code></a> for this.</p>
<p>With <a href="foldl.html"><code>foldl</code></a> you specify:</p>
<ul>
<li>the parser to parse the individual elements of the list (which is <code>int_token</code> in our example)</li>
<li>the initial value used for folding (which is <code>int_&lt;0&gt;</code> in our example)</li>
<li>the forward operation merging the sub-result we have so far and the value coming from the last application of the parser (this was <code>sum_op</code> in our example)</li>
</ul>
<p>Our parser can be implemented this way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> better_sum_parser = foldl&lt;int_token, mpl::int_&lt;<span class="dv">0</span>&gt;, sum_op&gt;;</code></pre>
<p>As you can see the implementation of the parser is more compact. Here is a diagram showing what happens when you use this parser to parse some input:</p>
<p align="center">
  
<a href="foldl_diag1.png"><img src="foldl_diag1.png" style="width:70%" /></a>
</p>

<p>As you can see, not only the implementation of the parser is more compact, but it achieves the same result by doing less as well. It parses the input by applying <code>int_token</code> repeatedly, just like the previous solution. But it produces the final result without buliding a typelist as an internal step. Here is how it works internally:</p>
<p align="center">
  
<a href="foldl_diag2.png"><img src="foldl_diag2.png" style="width:70%" /></a>
</p>

<p>It summarises the results of the repeated <code>int_token</code> application using <code>sum_op</code>. This implementation is more efficient. It accepts an empty string as a valid input: the sum of it is <code>0</code>. It may be good for you, in which case you are done. If you don't wan to accept it, you can use <a href="foldl1.html"><code>foldl1</code></a> instead of <a href="foldl.html"><code>foldl</code></a>. This is the same, but it rejects empty input. (Metaparse offers <a href="any1.html"><code>any1</code></a> as well if you choose the first approach and would like to reject empty string)</p>
<h4 id="introducing-foldr">Introducing foldr</h4>
<blockquote>
<p>Note that if you are reading this manual for the first time, you probably want to skip this section and proceed with <a href="manual.html#introducing-foldlp">Introducing foldlp</a></p>
</blockquote>
<p>You might have noticed that Metaparse offers <a href="foldr.html"><code>foldr</code></a> as well. The difference between <a href="foldl.html"><code>foldl</code></a> and <a href="foldr.html"><code>foldr</code></a> is the direction in which the results are summarised. (<code>l</code> stands for <em>from the Left</em> and <code>r</code> stands for <em>from the Right</em>) Here is a diagram showing how <code>better_sum_parser</code> works if it is implemented using <a href="foldr.html"><code>foldr</code></a>:</p>
<p align="center">
  
<a href="foldr_diag1.png"><img src="foldr_diag1.png" style="width:70%" /></a>
</p>

<p>As you can see this is very similar to using <a href="foldl.html"><code>foldl</code></a>, but the results coming out of the individual applications of <code>int_token</code> are summarised in a right-to-left order. As <code>sum_op</code> is addition, it does not affect the end result, but in other cases it might.</p>
<blockquote>
<p>Note that the implementation of <a href="foldl.html"><code>foldl</code></a> is more efficient than <a href="foldr.html"><code>foldr</code></a>. Prefer <a href="foldl.html"><code>foldl</code></a> whenever possible.</p>
</blockquote>
<p>As you might expect it, Metaparse offers <a href="foldr1.html"><code>foldr1</code></a> as well, which folds from the right and rejects empty input.</p>
<h4 id="introducing-foldlp">Introducing foldlp</h4>
<p>Let's change the grammar of our little language. Instead of a list of numbers, let's expect numbers separated by a <code>+</code> symbol. Our example input becomes the following:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">BOOST_STRING(<span class="st">&quot;11 + 13 + 3 + 21&quot;</span>)</code></pre>
<p>Parsing it with <a href="foldl.html"><code>foldl</code></a> or <a href="any.html"><code>any</code></a> is difficult: there has to be a <code>+</code> symbol before every element <em>except</em> the first one. None of the already introduced repetition constructs offer a way of treating the first element in a different way.</p>
<p>If we forget about the first number for a moment, the rest of the input is <code>&quot;+ 13 + 3 + 21&quot;</code>. This can easily be parsed by <a href="foldl.html"><code>foldl</code></a> (or <a href="any.html"><code>any</code></a>):</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> plus_token = token&lt;lit_c&lt;&#39;+&#39;&gt;&gt;;
<span class="kw">using</span> plus_int = last_of&lt;plus_token, int_token&gt;;

<span class="kw">using</span> sum_parser2 = foldl&lt;plus_int, int_&lt;<span class="dv">0</span>&gt;, sum_op&gt;;</code></pre>
<p>It uses <code>plus_int</code>, that is <a href="last_of.html"><code>last_of</code></a><code>&lt;plus_token, int_token&gt;</code> as the parser that is used repeatedly to get the numbers. It does the following:</p>
<ul>
<li>Uses <code>plus_token</code> to parse the <code>+</code> symbol and any whitespace that might follow it.</li>
<li>Uses then <code>int_token</code> to parse the number</li>
<li>Combines the above two with <a href="last_of.html"><code>last_of</code></a> to use both parsers in order and keep only the result of using the second one (the result of parsing the <code>+</code> symbol is thrown away - we don't care about it).</li>
</ul>
<p>This way <a href="last_of.html"><code>last_of</code></a><code>&lt;plus_token, int_token&gt;</code> returns the value of the number as the result of parsing, just like our previous parser, <code>int_token</code> did. Because of this, it can be used as a drop-in replacement of <code>int_token</code> in the previous example and we get a parser for our updated language. Or at least for all number except the first one.</p>
<p>This <a href="foldl.html"><code>foldl</code></a> can not parse the first element, because it expects a <code>+</code> symbol before every number. You might think of making the <code>+</code> symbol optional in the above approach - don't do that. It makes the parser accept <code>&quot;11 + 13 3 21&quot;</code> as well as the <code>+</code> symbol is now optional <em>everywhere</em>.</p>
<p>What you could do is parsing the first element with <code>int_token</code>, the rest of the elements with the above <a href="foldl.html"><code>foldl</code></a>-based solution and add the result of the two. This is left as an exercise to the reader.</p>
<p>Metaparse offers <a href="foldlp.html"><code>foldlp</code></a> to implement this. <a href="foldlp.html"><code>foldlp</code></a> is the same as <a href="foldl.html"><code>foldl</code></a>. The difference is that instead of an initial value to combine the list elements with it takes an <em>initial parser</em>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> plus_token = token&lt;lit_c&lt;&#39;+&#39;&gt;&gt;;
<span class="kw">using</span> plus_int = last_of&lt;plus_token, int_token&gt;;

<span class="kw">using</span> sum_parser3 = foldlp&lt;plus_int, int_token, sum_op&gt;;</code></pre>
<p><a href="foldlp.html"><code>foldlp</code></a> starts with applying that initial parser and uses the result it returns as the initial value for folding. It does the same as <a href="foldl.html"><code>foldl</code></a> after that. The following diagram shows how it can be used to parse a list of numbers separated by <code>+</code> symbols:</p>
<p align="center">
  
<a href="foldlp_diag1.png"><img src="foldlp_diag1.png" style="width:70%" /></a>
</p>

<p>As the diagram shows, it start parsing the list of numbers with <code>int_token</code>, uses its value as the starting value for folding (earlier approaches were using the value <code>int_&lt;0&gt;</code> as this starting value). Then it parses all elements of the list by using <code>plus_int</code> multiple times.</p>
<h4 id="introducing-foldrp">Introducing foldrp</h4>
<blockquote>
<p>Note that if you are reading this manual for the first time, you probably want to skip this section and try creating some parsers using <a href="foldlp.html"><code>foldlp</code></a> instead.</p>
</blockquote>
<p><a href="foldlp.hpp"><code>foldlp</code></a> has its <em>from the right</em> pair, <a href="foldrp.html"><code>foldrp</code></a>. It uses the same elements as <a href="foldlp.html"><code>foldlp</code></a> but in a different order. Here is a parser for our example language implemented with <a href="foldrp.html"><code>foldrp</code></a>:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> plus_token = token&lt;lit_c&lt;&#39;+&#39;&gt;&gt;;
<span class="kw">using</span> int_plus = first_of&lt;int_token, plus_token&gt;;

<span class="kw">using</span> sum_parser4 = foldrp&lt;int_plus, int_token, sum_op&gt;;</code></pre>
<p>Note that it uses <code>int_plus</code> instead of <code>plus_int</code>. This is because the parser the initial value for folding comes from is used after <code>int_plus</code> has parsed the input as many times as it could. It might sound strange for the first time, but the following diagram should help you understand how it works:</p>
<p align="center">
  
<a href="foldrp_diag1.png"><img src="foldrp_diag1.png" style="width:70%" /></a>
</p>

<p>As you can see, it starts with the parser that is applied repeatedly on the input, thus instead of parsing <code>plus_token int_token</code> repeatedly, we need to parse <code>int_token plus_token</code> repeatedly. The last number is not followed by <code>+</code>, thus <code>int_plus</code> fails to parse it and it stops the iteration. <a href="foldrp.html"><code>foldrp</code></a> then uses the other parser, <code>int_token</code> to parse the input. It succeeds and the result it returns is used as the starting value for folding from the right.</p>
<blockquote>
<p>Note that as the above description also suggests, the implementation of <a href="foldlp.html"><code>foldlp</code></a> is more efficient than <a href="foldrp.html"><code>foldrp</code></a>. Prefer <a href="foldlp.html"><code>foldlp</code></a> whenever possible.</p>
</blockquote>
<h4 id="introducing-foldlfp">Introducing foldlfp</h4>
<p>Using a parser built with <a href="foldlp.html"><code>foldlp</code></a> we can parse the input when the input is correct. However, it is not always the case. Consider the following input for example:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">BOOST_STRING(<span class="st">&quot;11 + 13 + 3 + 21 +&quot;</span>)</code></pre>
<p>This is an ivalid expression. However, if we parse it using the <code>foldlp</code>](foldlp.html)-based parser presented earlier (<code>sum_parser3</code>), it accepts the input and the result is <code>48</code>. This is because <a href="foldlp.html"><code>foldlp</code></a> parses the input <em>as long as it can</em>. It parses the first<code>int_token</code> (<code>11</code>) and then it starts parsing the <code>plus_int</code> elements (<code>+ 13</code>, <code>+ 3</code>, <code>+ 21</code>). After parsing all of these, it tries to parse the remaining <code>&quot; +&quot;</code> input using <code>plus_int</code> which fails and therefore <a href="foldlp.html"><code>foldlp</code></a> stops after <code>+ 21</code>.</p>
<p>The problem is that the parser parses the longest sub-expression starting from the beginning, that represents a valid expression. The rest is ignored. The parser can be wrapped by <a href="entire_input.html"><code>entire_input</code></a> to make sure to reject expressions with invalid extra characters at the end, however, that won't make the error message useful. (<a href="entire_input.html"><code>entire_input</code></a> can only tell the author of the invalid expression that after <code>+ 21</code> is something wrong).</p>
<p>Metaparse provides <a href="foldlfp.html"><code>foldlfp</code></a>, which does the same as <a href="foldlp.html"><code>foldlp</code></a>, except that once no further repetitions are found, it checks <em>where</em> the repeated parser (in our example <code>plus_int</code>) fails. When it can make any progress (eg. it finds a <code>+</code> symbol), then <a href="foldlfp.html"><code>foldlfp</code></a> assumes, that the expression's author intended to make the repetition longer, but made a mistake and propagates the error message coming from that last broken expression.</p>
<p align="center">
  
<a href="foldlfp_diag1.png"><img src="foldlfp_diag1.png" style="width:70%" /></a>
</p>

<p>The above diagram shows how <a href="foldlfp.html"><code>foldlfp</code></a> parses the example invalid input and how it fails. This can be used for better error reporting from the parsers.</p>
<p>Other folding parsers also have their <code>f</code> version. (eg. <a href="foldrf.html"><code>foldrf</code></a>, <a href="foldlf1.html"><code>foldlf1</code></a>, etc).</p>
<h4 id="finding-the-right-folding-parser-combinator">Finding the right folding parser combinator</h4>
<p>As you might have noticed, there are a lot of different folding parser combinators. To help you find the right one, the following naming convention is used:</p>
<p align="center">
  
<a href="folds.png"><img src="folds.png" style="width:70%" /></a>
</p>

<blockquote>
<p>Note that there is no <code>foldrfp</code>. The <code>p</code> version of the right-folding parsers applies the special parser, whose result is the initial value, after the repeated elements. Therefore, when the parser parsing one repeated element fails, <code>foldrp</code> would apply that special final parser instead of checking how the repeated element's parser failed.</p>
</blockquote>
<h3 id="grammars">Grammars</h3>
<p>Metaparse provides a way to define grammars in a syntax that resembles EBNF. The <a href="grammar.html"><code>grammar</code></a> template can be used to define a grammar. It can be used the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">grammar&lt;BOOST_STRING(<span class="st">&quot;plus_exp&quot;</span>)&gt;
  ::import&lt;BOOST_STRING(<span class="st">&quot;int_token&quot;</span>), token&lt;int_&gt;&gt;::type

  ::rule&lt;BOOST_STRING(<span class="st">&quot;ws ::= (&#39; &#39; | &#39;</span><span class="ch">\n</span><span class="st">&#39; | &#39;</span><span class="ch">\r</span><span class="st">&#39; | &#39;</span><span class="ch">\t</span><span class="st">&#39;)*&quot;</span>)&gt;::type
  ::rule&lt;BOOST_STRING(<span class="st">&quot;plus_token ::= &#39;+&#39; ws&quot;</span>), front&lt;_1&gt;&gt;::type
  ::rule&lt;BOOST_STRING(<span class="st">&quot;plus_exp ::= int_token (plus_token int_token)*&quot;</span>), plus_action&gt;::type</code></pre>
<p>The code above defines a parser from a grammar definition. The start symbol of the grammar is <code>plus_exp</code>. The lines beginning with <code>::rule</code> define rules. Rules optionally have a semantic action, which is a metafunction class that transforms the result of parsing after the rule has been applied. Existing parsers can be bound to names and be used in the rules by importing them. Lines beginning with <code>::import</code> bind existing parsers to names.</p>
<p>The result of a grammar definition is a parser which can be given to other parser combinators or be used directly. Given that grammars can import existing parsers and build new ones, they are parser combinators as well.</p>
<h2 id="parsing-based-on-constexpr">Parsing based on <code>constexpr</code></h2>
<p>Metaparse is based on template metaprogramming, however, C++11 provides <code>constexpr</code>, which can be used for parsing at compile-time as well. While implementing parsers based on <code>constexpr</code> is easier for a C++ developer, since its syntax resembles the regular syntax of the language, the result of parsing has to be a <code>constexpr</code> value. Parsers based on template metaprogramming can build types as the result of parsing. These types may be boxed <code>constexpr</code> values but can be metafunction classes, classes with static functions which can be called at runtime, etc.</p>
<p>When a parser built with Metaparse needs a sub-parser for processing a part of the input text and generating a <code>constexpr</code> value as the result of parsing, one can implement the sub-parser based on <code>constexpr</code> functions. Metaparse can be integrated with them and lift their results into C++ template metaprogramming. An example demonstrating this feature can be found among the examples (<code>constexpr_parser</code>). This capability makes it possible to integrate Metaparse with parsing libraries based on <code>constexpr</code>.</p>
<h2 id="monadic-parsing">Monadic parsing</h2>
<p>Metaparse provides a parsing monad implementation based on Metamonad's monadic framework. The overloads of <code>bind</code> and <code>return_</code> can be loaded by including <code>boost/metaparse/parser_monad.hpp</code>.</p>
<p>Monadic values are parsers. The monadic <code>return_</code> operation constructs a <code>return_</code> parser. The arguments of the monadic <code>bind</code> are a parser <code>P</code> and a function <code>F</code>, taking a value and buliding a parser. <code>bind</code> constructs the following parser:</p>
<ul>
<li>It parses the input using <code>P</code>.</li>
<li>When <code>P</code> fails, the error is propagated.</li>
<li>When <code>P</code> succeeds, the result is passed to <code>F</code> and the remaining input is parsed using the parser returned by <code>F</code>.</li>
</ul>
<p class="copyright">
Copyright Abel Sinkovics (abel at elte dot hu) 2011. Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>
</p>

<p><a href="index.html">[up]</a></p>
</body>
</html>

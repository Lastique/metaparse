<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<h1 id="grammar">grammar</h1>
<h2 id="synopsis">Synopsis</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> StartSymbol = BOOST_STRING(<span class="st">&quot;S&quot;</span>)&gt;
<span class="kw">struct</span> grammar
{
  <span class="kw">template</span> &lt;<span class="kw">class</span> S, <span class="kw">class</span> Pos&gt;
  <span class="kw">struct</span> apply;

  <span class="kw">template</span> &lt;<span class="kw">class</span> Name, <span class="kw">class</span> P&gt;
  <span class="kw">struct</span> import;

  <span class="kw">template</span> &lt;<span class="kw">class</span> S, <span class="kw">class</span> Action = <span class="co">/* unspecified */</span>&gt;
  <span class="kw">struct</span> rule;
};</code></pre>
<h2 id="description">Description</h2>
<blockquote>
<p>Note that using this adds a significant overhead to your builds. When someone uses your parser, the compiler will have to build your grammar parser, use it to parse your grammar and build your parser and then it can parse the input the user would like to parse with your parser. You might consider using the parser combinators the library provides.</p>
</blockquote>
<p>Parser combinator for constructing parsers based on an embedded DSL similar to EBNF. It can be used the following way:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">grammar&lt;&gt;
  <span class="co">// definitions</span></code></pre>
<p>where a definition can be a rule or an import command.</p>
<p>Rules look like on of the following:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  ::rule&lt;BOOST_STRING(<span class="st">&quot;name ::= def&quot;</span>)&gt;
  ::rule&lt;BOOST_STRING(<span class="st">&quot;name ::= def&quot;</span>), semantic_action&gt;</code></pre>
<p><code>name</code> consists of letters, digits and the <code>_</code> character. It is the name of the symbol being defined. <code>def</code> describes the rule. It can be</p>
<ul>
<li>the name of a symbol</li>
<li>a terminal, which is a character between single quotes. <code>\</code> can be used for escaping. The following are accepted: <code>\n</code>, <code>\r</code>, <code>\t</code>, <code>\\</code>, <code>\'</code></li>
<li>a sequence of definitions</li>
<li>a definition followed by the <code>*</code> character, which means repetition accepting 0 match</li>
<li>a definition followed by the <code>+</code> character, which means repetition expecting at least one match</li>
<li>a definition in brackets</li>
</ul>
<p>Rules take an optional <code>semantic_action</code> argument. It is a placeholder expression taking one argument. When this is given, this is used to transform the result of the rule.</p>
<p>Imports can be used to turn an arbitrary parser into a symbol available for the rules. Import definitions look like the following:</p>
<pre class="sourceCode cpp"><code class="sourceCode cpp">  ::import&lt;BOOST_STRING(<span class="st">&quot;name&quot;</span>), parser&gt;</code></pre>
<p><code>name</code> is the name of the symbol, <code>parser</code> is the parser to bind the name to.</p>
<p>The start symbol of the grammar is specified by the template argument of the <code>grammar</code> template. This is optional, the default value is <code>S</code>.</p>
<h2 id="header">Header</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;boost/metaparse/grammar.hpp&gt;</span></code></pre>
<h2 id="example">Example</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#define BOOST_LIMIT_STRING_SIZE 64</span>

<span class="ot">#include &lt;boost/metaparse/grammar.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/token.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/int_.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/entire_input.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/build_parser.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/string.hpp&gt;</span>

<span class="ot">#include &lt;boost/mpl/front.hpp&gt;</span>
<span class="ot">#include &lt;boost/mpl/back.hpp&gt;</span>
<span class="ot">#include &lt;boost/mpl/plus.hpp&gt;</span>
<span class="ot">#include &lt;boost/mpl/fold.hpp&gt;</span>
<span class="ot">#include &lt;boost/mpl/lambda.hpp&gt;</span>

<span class="kw">using</span> boost::metaparse::token;
<span class="kw">using</span> boost::metaparse::int_;
<span class="kw">using</span> boost::metaparse::build_parser;
<span class="kw">using</span> boost::metaparse::entire_input;
<span class="kw">using</span> boost::metaparse::grammar;

<span class="kw">using</span> boost::mpl::front;
<span class="kw">using</span> boost::mpl::back;
<span class="kw">using</span> boost::mpl::plus;
<span class="kw">using</span> boost::mpl::fold;
<span class="kw">using</span> boost::mpl::lambda;
<span class="kw">using</span> boost::mpl::_1;
<span class="kw">using</span> boost::mpl::_2;

<span class="kw">template</span> &lt;<span class="kw">class</span> A, <span class="kw">class</span> B&gt;
<span class="kw">struct</span> lazy_plus : boost::mpl::plus&lt;<span class="kw">typename</span> A::type, <span class="kw">typename</span> B::type&gt; {};

<span class="kw">template</span> &lt;<span class="kw">class</span> Sequence, <span class="kw">class</span> State, <span class="kw">class</span> ForwardOp&gt;
<span class="kw">struct</span> lazy_fold :
  fold&lt;<span class="kw">typename</span> Sequence::type, <span class="kw">typename</span> State::type, <span class="kw">typename</span> ForwardOp::type&gt;
{};

<span class="kw">using</span> plus_action =
  lazy_fold&lt;back&lt;_1&gt;, front&lt;_1&gt;, lambda&lt;lazy_plus&lt;_1, back&lt;_2&gt;&gt;&gt;::type&gt;;

<span class="kw">using</span> plus_grammar =
  grammar&lt;BOOST_STRING(<span class="st">&quot;plus_exp&quot;</span>)&gt;
    ::import&lt;BOOST_STRING(<span class="st">&quot;int_token&quot;</span>), token&lt;int_&gt;&gt;::type

    ::rule&lt;BOOST_STRING(<span class="st">&quot;ws ::= (&#39; &#39; | &#39;</span><span class="ch">\n</span><span class="st">&#39; | &#39;</span><span class="ch">\r</span><span class="st">&#39; | &#39;</span><span class="ch">\t</span><span class="st">&#39;)*&quot;</span>)&gt;::type
    ::rule&lt;BOOST_STRING(<span class="st">&quot;plus_token ::= &#39;+&#39; ws&quot;</span>), front&lt;_1&gt;&gt;::type
    ::rule&lt;BOOST_STRING(<span class="st">&quot;plus_exp ::= int_token (plus_token int_token)*&quot;</span>), plus_action&gt;::type
  ;

<span class="kw">using</span> plus_parser = build_parser&lt;entire_input&lt;plus_grammar&gt;&gt;;

<span class="kw">static_assert</span>(
  plus_parser::apply&lt;BOOST_STRING(<span class="st">&quot;1 + 2 + 3 + 4&quot;</span>)&gt;::type::value == <span class="dv">10</span>,
  <span class="st">&quot;Arithmetic expression should be evaluated&quot;</span>
);</code></pre>
<p class="copyright">
Copyright Abel Sinkovics (abel at elte dot hu) 2011. Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>
</p>

<p><a href="reference.html">[up]</a></p>
</body>
</html>

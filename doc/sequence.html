<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<h1 id="sequence">sequence</h1>
<h2 id="synopsis">Synopsis</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> P1, <span class="co">/* ... */</span>, <span class="kw">class</span> Pn&gt;
<span class="kw">struct</span> sequence;</code></pre>
<p>This is a <a href="parser_combinator.html">parser combinator</a>.</p>
<h2 id="arguments">Arguments</h2>
<table cellpadding='0' cellspacing='0'>
  <tr>
    <td>
<code>P1</code> .. <code>Pn</code>
</td>
    <td>
<a href="parser.html">parser</a>
</td>
  </tr>
</table>

<h2 id="description">Description</h2>
<p><code>sequence</code> applies the <code>P1</code>, ..., <code>Pn</code> parsers in sequence on the input. It accepts an input when all of these parsers accept it. The result of parsing is a sequence of the results of the parsers.</p>
<p>The maximum number of parsers <code>sequence</code> accepts can be specified with the <code>BOOST_LIMIT_SEQUENCE_SIZE</code> macro. Its default value is <code>5</code>.</p>
<h2 id="header">Header</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;boost/metaparse/sequence.hpp&gt;</span></code></pre>
<h2 id="expression-semantics">Expression semantics</h2>
<p>For any <code>n &gt; 0</code>, <code>p0</code>, ..., <code>pn</code> parsers the result of <code>sequence&lt;p0, ..., p1&gt;</code> is a compile-time sequence of the results of the parsers, applied after each other in order on the input string when none of them returns an error. The remaining string is the remaining string the last parser returns.</p>
<p>When one of the parsers returns an error, the combinator returns that error.</p>
<h2 id="example">Example</h2>
<pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="ot">#include &lt;boost/metaparse/sequence.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/token.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/int_.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/lit_c.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/start.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/string.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/is_error.hpp&gt;</span>
<span class="ot">#include &lt;boost/metaparse/get_result.hpp&gt;</span>

<span class="ot">#include &lt;boost/mpl/at.hpp&gt;</span>

<span class="kw">using</span> <span class="kw">namespace</span> boost::metaparse;

<span class="kw">using</span> int_token = token&lt;int_&gt;;
<span class="kw">using</span> plus_token = token&lt;lit_c&lt;&#39;+&#39;&gt;&gt;;

<span class="kw">using</span> a_plus_b = sequence&lt;int_token, plus_token, int_token&gt;;

<span class="kw">static_assert</span>(
  boost::mpl::at_c&lt;
    get_result&lt;a_plus_b::apply&lt;BOOST_STRING(<span class="st">&quot;1 + 2&quot;</span>), start&gt;&gt;::type,
    <span class="dv">0</span>
  &gt;::type::value == <span class="dv">1</span>,
  <span class="st">&quot;the first element of the sequence should be the first number&quot;</span>
);

<span class="kw">static_assert</span>(
  boost::mpl::at_c&lt;
    get_result&lt;a_plus_b::apply&lt;BOOST_STRING(<span class="st">&quot;1 + 2&quot;</span>), start&gt;&gt;::type,
    <span class="dv">1</span>
  &gt;::type::value == &#39;+&#39;,
  <span class="st">&quot;the second element of the sequence should be the plus&quot;</span>
);

<span class="kw">static_assert</span>(
  boost::mpl::at_c&lt;
    get_result&lt;a_plus_b::apply&lt;BOOST_STRING(<span class="st">&quot;1 + 2&quot;</span>), start&gt;&gt;::type,
    <span class="dv">2</span>
  &gt;::type::value == <span class="dv">2</span>,
  <span class="st">&quot;the third element of the sequence should be the second number&quot;</span>
);

<span class="kw">static_assert</span>(
  is_error&lt;a_plus_b::apply&lt;BOOST_STRING(<span class="st">&quot;1 +&quot;</span>), start&gt;&gt;::type::value,
  <span class="st">&quot;when not all of the parsers accept the input, sequence should fail&quot;</span>
);</code></pre>
<p class="copyright">
Copyright Abel Sinkovics (abel at elte dot hu) 2011. Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>
</p>

<p><a href="reference.html">[up]</a></p>
</body>
</html>
